Dominika Janczyszyn - AR Lab 1

During the first lab session of our AR project, our main objective was to build the foundation for our augmented reality solar system. This project idea was inspired by the United Nations’ 4th Sustainable Development Goal (Quality Education), which emphasizes inclusive access to high-quality learning resources and innovative teaching methods. By creating an interactive AR solar system, our aim was to support engaging, technology-based science education that can help learners better visualize astronomical concepts. 

The focus for this session was to create a functional 3D model of the solar system that could be placed on a real surface using AR, while simulating realistic planetary orbits and rotations around the sun. This session was therefore centered around combining visual modeling, physics-based scripting, and AR placement to establish the core of our project.
We began by setting up a 3D scene in Unity and creating a structure for our solar system. To achieve a visually convincing result, we decided to use open-source 3D planet models that came with realistic surface textures and materials. This choice allowed us to give the planets a polished appearance, but  avoid manual modeling or texture creation. Each planet was then positioned relative to the sun, which served as the central object in the scene.

The next step was to implement the motion system that would make each planet orbit around the sun and rotate around its own axis. To achieve this, we created a C# script called PlanetOrbit.cs, which handled both the orbital motion and the planet’s self-rotation. The orbital movement was implemented using Unity’s Transform.RotateAround() function, which rotates an object around a given point and axis. In this case, the point was the sun’s position, and the axis represented the orbital plane. In addition to orbiting, each planet also rotated around its spin axis to simulate day and night cycles.

We also introduced an axial tilt parameter to make the rotations more realistic. This was implemented by calculating the spin axis in the Start() method using a quaternion rotation based on the specified tilt angle. For example, Earth was given a tilt of 23.5 degrees. During the Update() loop, both the orbital rotation and the self-rotation were updated every frame, creating a smooth and continuous motion for all planets.

While we referenced real astronomical data for the rotation and orbital speeds, we decided to make several adjustments for better visualization. Using accurate physical values resulted in movements that were either too slow to notice or distances that were too large for a tabletop setup. To solve this, we proportionally scaled the orbit speeds and reduced the orbital radio so that all planets would remain visible within a small area. We also slightly increased the size of the smaller planets such as Mercury and Pluto, ensuring they were still easy to observe within the AR scene.

After the planetary motion was complete, we moved on to integrating the solar system into an AR environment using Unity’s AR Foundation. For this part, we developed two scripts: PressInputBase.cs and Placer.cs. The first one handled general input interactions by detecting screen presses using Unity’s new Input System. It defined virtual methods that could be customized depending on what action was needed when a press was detected. The Placer script extended this system and handled the actual AR raycasting process. When the user tapped on the screen, a ray was cast into the AR scene using ARRaycastManager, and if it intersected with a detected surface, the solar system prefab was instantiated at that location. We added a small offset to the Y position to make sure the solar system appeared slightly above the detected surface, avoiding any clipping issues with the table. We also included a simple safeguard so that the system could only be placed once during a session, preventing multiple instances from being created.

One of the challenges we faced during this lab was finding the right balance between realism and usability. When we used real astronomical values, the planets became either too small or too distant from the sun to be visually effective in AR. The scaled version we implemented maintained the correct sense of structure and proportion but allowed for a more engaging and understandable viewing experience. We also encountered minor difficulties with aligning the tilt and rotation of each planet, but using quaternion-based transformations resolved these issues and produced smooth, accurate motions.

By the end of the session, we successfully created a working prototype of our tabletop solar system. The planets orbited and rotated around the sun in a visually convincing manner, and the entire system could be placed on any detected surface using a mobile AR device. Although we made several simplifications for visibility and performance, the final result effectively demonstrated the core concept of our project and established the technical foundation for future development.

This session helped us gain a deeper understanding of Unity’s transformation system, AR Foundation’s plane detection and placement features, and the challenges of adapting real-world physical data into interactive visual simulations. Overall, the lab was highly productive, and it provided a solid groundwork for the following sessions, where we plan to focus on improving user interaction and adding a user interface for displaying planet information.
